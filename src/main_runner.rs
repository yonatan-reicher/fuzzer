use crate::fuzzer::Fuzzer;
use crate::runner::{ProgramResult, Runner};
use shared_child::SharedChild;
use std::{
    fmt::{self, Display, Formatter},
    io::{self, Write},
    path::{Path, PathBuf},
    sync::Arc,
    time::Duration,
};
use crate::flag::Flag;
use crate::delay::Delayer;


const SINGLE_EXECUTION_TIMEOUT_SECS: f32 = 1.05;

/// This runner takes a fuzzer, a total timeout, and an executable path. It
/// runs the executable with the input generated by the fuzzer until the total
/// timeout is reached.
///
/// Every execution has it's own individual timeout of `SINGLE_EXECUTION_TIMEOUT_SECS`.
pub struct MainRunner<F: Fuzzer> {
    executable: PathBuf,
    fuzzer: F,
    single_execution_timeout: Duration,
}

#[derive(Debug, Clone, Copy)]
enum WaitWithTimeoutResult {
    Finished(std::process::ExitStatus),
    Timeout,
}
impl<T: Fuzzer> MainRunner<T> {
    pub fn new(executable: PathBuf, fuzzer: T) -> Self {
        Self {
            executable,
            fuzzer,
            single_execution_timeout: Duration::from_secs_f32(SINGLE_EXECUTION_TIMEOUT_SECS),
        }
    }
}

/// Spawn a process with the given executable path and write the input to its
/// stdin.
fn spawn_with_stdin(executable: &Path, input: &[u8]) -> io::Result<SharedChild> {
    // TODO: Can we limit Command::new to only absolute paths?
    let child = SharedChild::spawn(
        std::process::Command::new(executable)
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::null())
            .stderr(std::process::Stdio::null()),
    )?;
    child
        .take_stdin()
        .as_mut()
        .ok_or(io::Error::new(
            io::ErrorKind::Other,
            "could not open stdin pipe",
        ))?
        .write_all(input)?;
    Ok(child)
}

fn wait_with_timeout(
    child: Arc<SharedChild>,
    timeout: Duration,
    delayer: &Delayer<Box<dyn FnOnce() + Send + 'static>>,
) -> WaitWithTimeoutResult {
    let was_killed = Flag::default();

    // Kill the child process after the timeout
    {
        let raise_was_killed = was_killed.get_raise();
        let child = child.clone();
        delayer.set(timeout, Box::new(move || {
            raise_was_killed();
            child.kill().expect("could not kill child process");
        }));
    }

    let exit_status = child.wait().expect("could not wait for child process");
    delayer.cancel();
    if was_killed.is_raised() {
        WaitWithTimeoutResult::Timeout
    } else {
        WaitWithTimeoutResult::Finished(exit_status)
    }
}

struct InputFoundPrinter(Vec<u8>);

impl Display for InputFoundPrinter {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        let bytes = &self.0;
        if let Ok(string) = std::str::from_utf8(bytes) {
            write!(f, "{}", string)
        } else {
            write!(f, "{:?}", bytes)
        }
    }
}

impl<F: Fuzzer> MainRunner<F> {
    fn search_for_input(&mut self) -> Vec<u8> {
        let delayer = Delayer::new();
        loop {
            let input = self.fuzzer.generate_input();
            let child = spawn_with_stdin(&self.executable, &input)
                .expect("could not spawn child process");
            let result = wait_with_timeout(child.into(), self.single_execution_timeout, &delayer);
            match result {
                WaitWithTimeoutResult::Finished(exit_status) => {

                    if !exit_status.success() {
                        return input;
                    }
                }
                WaitWithTimeoutResult::Timeout => return input,
            }
        }
    }
}

impl<T: Fuzzer + Send> Runner for MainRunner<T> {
    fn run(&mut self) {
        let input_found = self.search_for_input();
        println!(
            "Execution succeeded. Output: '{}'",
            InputFoundPrinter(input_found)
        )
    }

    fn run_with_input(&mut self, _input: &[u8]) -> Result<ProgramResult, String> {
        todo!()
    }
}
