from dataclasses import dataclass
from typing import Callable
import os
import subprocess
import sys


THIS_DIR = os.path.realpath(os.path.dirname(__file__))
WORDS_PATH = THIS_DIR + "/words.txt"
GENERATE_WORDS_CPP_PATH = THIS_DIR + "/generate_words.cpp"
# Use EXE so it works both on Windows and Linux
GENERATE_WORDS_EXE_PATH = THIS_DIR + "/generate_words.exe"
BIG_LIST_OF_NAUGTHY_STRINGS_PATH = "./resources/big-list-of-naughty-strings.txt"


def get_big_list_of_naugthy_strings() -> list[bytes]:
    with open(BIG_LIST_OF_NAUGTHY_STRINGS_PATH, "rb") as f:
        return f.read().splitlines()


def compile_word_generator():
    subprocess.run(
        [
            "g++",
            "-O2",
            "-o",
            GENERATE_WORDS_EXE_PATH,
            GENERATE_WORDS_CPP_PATH
        ],
        check=True,
    )


def run_word_generator():
    subprocess.run(
        [
            "cargo",
            "run",
            "--release",
            "--",
            "--strings",
            GENERATE_WORDS_EXE_PATH,
        ],
        check=True,
    )


def rm_words():
    subprocess.run(
        [
            "rm",
            WORDS_PATH,
        ],
    )


def rm_word_generator():
    subprocess.run(
        [
            "rm",
            GENERATE_WORDS_EXE_PATH,
        ],
        check=True,
    )


def generate_words():
    compile_word_generator()
    rm_words()
    run_word_generator()
    rm_word_generator()


def read_words(file_path=WORDS_PATH) -> dict[bytes, int]:
    ret = {}
    count = 0
    with open(file_path, "rb") as f:
        try:
            while True:
                len_bytes = f.read(8)
                if len_bytes == b'':
                    break
                len = int.from_bytes(
                    len_bytes, signed=False, byteorder='little')
                word = f.read(len)
                if word not in ret:
                    ret[word] = 0
                ret[word] += 1
                count += 1
        except:
            print(f"Error reading word number {count}")
    return ret


def prettify_word(word: bytes, max_chars: int | None = 150) -> str:
    if max_chars is None:
        word_str = None
        try:
            # a space to align with b'...'
            word_str = ' "' + word.decode("utf-8") + '"'
        except:
            pass

        return (
            word_str
            if word_str and word_str != '' and word_str.isprintable() else
            str(word)
        )

    p = prettify_word(word, None)
    if len(p) <= max_chars:
        return p
    return p[:max_chars - 3] + "..."


Words = dict[bytes, int]


@dataclass
class Info:
    words: Words
    naughty_strings: set[bytes]


def help(_):
    print(help_message)


def sorted_by_count(info: Info) -> list[tuple[bytes, int]]:
    return sorted(info.words.items(), key=lambda item: (item[1], item[0]))


def show_by_count(info: Info):
    for (word, count) in sorted_by_count(info):
        print(f"{count}: {prettify_word(word)}")


def show_naughty_by_count(info: Info):
    for (word, count) in sorted_by_count(info):
        if word in info.naughty_strings:
            print(f"{count}: {prettify_word(word)}")


def show_generated_by_count(info: Info):
    for (word, count) in sorted_by_count(info):
        if word not in info.naughty_strings:
            print(f"{count}: {prettify_word(word)}")


def show_filtered(info: Info):
    expr = input("Enter filter: ")
    try:
        for (word, count) in sorted_by_count(info):
            locals = {
                "count": count,
                "word": word,
                "is_naughty": word in info.naughty_strings,
                "is_generated": word not in info.naughty_strings,
            }
            if eval(expr, {}, locals):
                print(f"{count}: {prettify_word(word)}")
    except Exception as e:
        print(f"Error: {e}")


commands: dict[str, Callable] = {
    "help": help,
    "by count": show_by_count,
    "naughty by count": show_naughty_by_count,
    "generated by count": show_generated_by_count,
    "filter": show_filtered,
    "total amount": lambda info: print(sum(info.words.values())),
    "exit": lambda _: exit(0),
}


help_message = """
Commands:
""" + "\n".join(f"\t{command}" for command in commands) + """

Filtering:
The filter command takes a python condition as argument, with the given
variables available: count, word, is_naughty, is_generated.
"""


def do_command(command: str, words: Words, naughty_strings: set[bytes]):
    if command not in commands:
        print("Unknown command")
        return
    commands[command](Info(words=words, naughty_strings=naughty_strings))


@dataclass
class Args:
    skip: bool


def parse_args(args: list[str]) -> Args:
    match args:
        case []:
            return Args(skip=False)
        case ["--skip"]:
            return Args(skip=True)
        case _:
            print("Unknown arguments")
            print('Usage: python main.py [--skip]')
            exit(1)


def main():
    args = parse_args(sys.argv[1:])

    if not args.skip:
        generate_words()

    words = read_words()
    naughty_strings = set(get_big_list_of_naugthy_strings())

    print("Type 'help' for help")

    while True:
        command = input('Enter a command: ').strip()
        do_command(command, words, naughty_strings)


if __name__ == "__main__":
    main()
